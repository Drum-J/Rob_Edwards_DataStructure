### Heap Sort

힙 정렬 알고리즘에 대해 알아보자.

---

이번 강의는 정말 힙 정렬 그 자체였다. 힙 정렬이 어떻게 이루어지는지 몸소 하나하나 알려줬기 때문에 재밌게 집중할 수 있었고 그 방식에 대해 절대 까먹지 않을 것 같다 ㅋㅋ

앞에 기록(1-04)의 마지막 부분에 남긴 것 처럼 heap 의 remove()를 계속해서 반복하면 배열이 오름차순으로 정렬이 완성된다!

여기서 remove()를 할 때 왜 root의 값을 덮어씌워서 지우지 않고 마지막 노드와 스왑해서 남겨 놓는지 알 수 있었다.

lastposition을 1 감소 시켜서 heap에서는 그 값을 파악하고 있지 않지만 배열에서 본다면 맨 오른쪽에 해당 값을 계속 가지고 있기 때문에 정렬이 되는 것.

LinkedList 에서 포인터가 더 이상 해당 노드를 가리키지 않을 때 LinkedList에서 제외되는 것과 유사하다.

단, 여기서는 GC가 일어나진 않고 Heap 에서만 해당 값을 판단하지 않을뿐 배열에서는 고대로 가지고 있다는게 핵심이다!

그래서 Heap 을 remove() 할 수록 heap은 없어지지만 그 heap을 나타내는 배열은 그대로 남아서 차곡차곡 정렬되고 있던 것.

---

### 힙 정렬의 시간 복잡도

힙 정렬의 시간 복잡도는 O(n log n) 이 걸린다고 한다.

총 n개의 숫자를 (log n)개의 숫자와 비교했기 때문이라고 한다. 

(log 에 대해 잠깐 다시 찾아봤다 알고리즘에서 사용하는 log가 log2 이다. 즉 log n 은 log2 n 이라는 말이다.<br>
n = 16 이라고 한다면 log n = 4 가 된다.) 총 16개의 숫자를 4개의 숫자와 비교했다는 뜻.

다른 정렬들이 대부분 O(n2)의 시간 복잡도를 가진다는 점에서 힙 정렬은 꽤나 괜찮은 정렬인 것 같다.

---

### 힙 정렬의 또 다른 장점

힙 정렬은 하나의 배열에서 시작해서 그 배열에서 정렬된 상태로 끝난다는 것이다.

어떤 방식으로든 데이터의 복사본을 만들지 않는다는 뜻!

힙 정렬은 표준적인 정렬 알고리즘이라고 한다.
