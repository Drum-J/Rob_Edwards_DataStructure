## 데이터 형식에 의존하지 않는 제네릭 프로그래밍에 대해서 알아보자

우선 아주 엄청나게 환상적인 정렬 알고리즘을 만들어 냈다고 가정하자!! (브릴리언트, 판타스틱, 엄~메이징 소팅 알고리즘)
```java
public class ss{
  public int[] superSort(int[] array) {
    ... sort ...
    return array;
    }
}
```
위 코드는 int 배열을 정렬하는 알고리즘이다. 그렇다면 이제 문자열을 정렬하고 싶다면 어떻게 해야할까??
`public String[] ~~~` 으로 바꿔주면 될까??

그러기엔 또 똑같은 코드를 작성해야한다.... 휴...
여기서!! 제네릭 프로그래밍을 사용하도록 하자! 오늘 알아볼 내용이다.

제네릭 프로그래밍의 목표는!! 해당 알고리즘을 가지고 `모든 것`들을 정렬할 수 있게 하는 것이다. (모든 알고리즘의 신...)

---

### 제네릭 프로그래밍

다양한 자료형의 객체에 대해 작성한 코드를 재사용한다는 객체 지향 기법이다.

그렇다면 제네릭으로 어떻게 코드를 짜야할까...? 그 방법에 대해서 강의에서 나오지는 않았지만 내가 아는 한에서 짜보자.

```java
public class ss{
  public T[] superSort(T[] array) {
    ... sort ...
    return array;
    }
}
```
가장 단순하게 생각하면 `int[]` 부분을 `T[]` 로 바꿔주면 되겠다. 하지만 실제로 내가 사용할때는 array에서 제네릭을 사용한 적이 없다.
<br>그래서 알아보니 제네릭으로 Array는 직접 생성이 불가능 하다고 알려준다.

- 배열은 공변하며 런타임에 실체화 되지만, 제네릭 타입은 불공변하며 런타임에 소거됩니다.
- 이로 인해 배열은 타입 안전성을 보장해줄 수 없어 제네릭 배열을 직접 생성할 수 없습니다.
- 타입 안전성을 위해서라면 배열을 사용하기 보다 제네릭 타입을 활용한 리스트를 사용하는 것이 좋습니다.

해당 [블로그](https://pompitzz.github.io/blog/Java/whyCantCreateGenericsArray.html#%E1%84%8C%E1%85%A6%E1%84%82%E1%85%A6%E1%84%85%E1%85%B5%E1%86%A8%E1%84%80%E1%85%AA-%E1%84%87%E1%85%A2%E1%84%8B%E1%85%A7%E1%86%AF%E1%84%8B%E1%85%B4-%E1%84%8E%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A5%E1%86%B7)에 아주 잘 설명이 되어 있다.
<br>List<T> 를 활용해서 코드를 작성하는게 좋다고 한다. 그래서 강의에서도 그냥 설명만 하고 넘어간건가...??
  
  ---
  
  ### 다양한 객체에 대해 설명
  제네릭을 설명하면서 다시 한 번 객체들의 메소드 오버라이드에 대해 설명해주었다. 해당 내용은 강의를 다시 들어보는게 아주 좋을 것 같다.
  <br>강의만큼 잘 설명할 수 없는 나의 한계...  마지막으로 Parameterize Types 를 언급하면서 강의가 끝이난다.
